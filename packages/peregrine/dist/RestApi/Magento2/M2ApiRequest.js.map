{"version":3,"sources":["../../../src/RestApi/Magento2/M2ApiRequest.js"],"names":["M2ApiResponseError","MulticastCache","BrowserPersistence","withDefaultHeaders","headerAdditions","headers","Headers","Accept","entries","name","value","append","forEach","console","warn","Object","M2ApiRequest","resourceUrl","opts","storage","signin_token","getItem","controller","AbortController","method","signal","credentials","authorization","_isMulticastable","_promise","_fetchMulticast","_fetch","Error","then","res","clone","abort","cache","hasOwnProperty","multicast","body","window","fetch","_transport","remove","e","response","ok","text","bodyText","inflightMatch","match","rolling","isRolling","getResponse","store","promise","catch","error","replacedInFlightMatch","abortRequest","request","req","run","parseJSON","json"],"mappings":"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","sourcesContent":["import M2ApiResponseError from './M2ApiResponseError';\nimport * as MulticastCache from './MulticastCache';\nimport { BrowserPersistence } from '../../util/';\n\n// TODO: headers are locked right now, add configurability\nconst withDefaultHeaders = headerAdditions => {\n    const headers = new Headers({\n        'Content-type': 'application/json',\n        Accept: 'application/json'\n    });\n    if (headerAdditions) {\n        if (headerAdditions instanceof Headers) {\n            /* istanbul ignore next: current phantomJS doesn't support */\n            if (headerAdditions.entries) {\n                for (const [name, value] of headerAdditions) {\n                    headers.append(name, value);\n                }\n            } else if (headerAdditions.forEach) {\n                // cover legacy case for old test environments\n                headerAdditions.forEach((name, value) => {\n                    headers.append(name, value);\n                });\n                /* istanbul ignore next: should never happen, trivial to test*/\n            } else {\n                console.warn(\n                    'Could not use headers object supplied to M2ApiRequest',\n                    headerAdditions\n                );\n            }\n        } else {\n            for (const [name, value] of Object.entries(headerAdditions)) {\n                headers.append(name, value);\n            }\n        }\n    }\n    return headers;\n};\n\n/**\n * All [fetch options](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters) are passed through, with the addition of:\n * @typedef {Object} M2ApiRequestOptions\n * @property {boolean} [multicast] Override default multicast detection\n */\n\n/**\n * A request to the Magento 2 REST API. Returns a Promise created by a network\n * fetch, but can potentially reuse prior requests if they qualify for\n * multicast. Can abort an outstanding fetch request.\n *\n * @param {M2ApiRequestOptions} opts - All other [fetch options](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters) will be passed through to `fetch`.\n */\nclass M2ApiRequest {\n    constructor(resourceUrl, opts = {}) {\n        const storage = new BrowserPersistence();\n        const signin_token = storage.getItem('signin_token');\n        this.controller = new AbortController();\n        this.resourceUrl = resourceUrl;\n        // merge headers specially\n        this.opts = {\n            // can be overridden\n            method: 'GET',\n            signal: this.controller.signal,\n            credentials: 'include',\n            ...opts,\n            // cannot be overridden, only appended to\n            headers: withDefaultHeaders(\n                new Headers({\n                    authorization: signin_token ? `Bearer ${signin_token}` : ''\n                })\n            )\n        };\n    }\n    /**\n     * Execute the request. Must be run before {@link M2ApiRequest#getResponse}\n     * or {@link M2ApiRequest#cancel} can be called.\n     */\n    run() {\n        if (this._isMulticastable()) {\n            this._promise = this._fetchMulticast();\n        } else {\n            this._promise = this._fetch();\n        }\n    }\n    /**\n     * Get the promise for the network operation. Can only be called after\n     * `.run()` is called.\n     * For multicast requests, will return a promise for a new copy of the\n     * response every time it is called, since a Body can only be used once.\n     * Exists so that requests can reuse the promises from other requests.\n     * @returns {Promise} Promise for the result of the request.\n     */\n    getResponse() {\n        if (!this._promise) {\n            throw new Error(\n                'M2ApiRequest#getResponse() called before M2ApiRequest#run(), so no promise exists yet'\n            );\n        }\n        if (this._isMulticastable()) {\n            return this._promise.then(res => res.clone());\n        } else {\n            return this._promise;\n        }\n    }\n    /**\n     * Abort the network operation. Multicasted requests catch the AbortError\n     * and attempt to reuse a more recent matching request from cache. Other\n     * requests will pass the AbortError rejection through to the consumer.\n     */\n    abortRequest() {\n        this.controller.abort();\n    }\n    /**\n     * Check if this request intends to override prior requests to the same\n     * resource. Rolling requests will take the place of prior outstanding\n     * requests, to ensure the freshest resource at the cost of additional\n     * network calls.\n     *\n     * The current logic for rolling requests is determined by the `cache`\n     * option. [Cache modes](https://developer.mozilla.org/en-US/docs/Web/API/Request/cache)\n     * `reload` and `no-store` both indicate complete cache bypass. This\n     * logically implies that the user has just changed server state and wants\n     * to force retrieve an updated resource, so multicasting a prior request\n     * would not be appropriate--the response may not reflect the more recent\n     * change.\n     * @returns {boolean} True if the request is rolling.\n     */\n    isRolling() {\n        return this.opts.cache === 'no-store' || this.opts.cache === 'reload';\n    }\n    /**\n     * Make sure not to multicast POST requests which have a nonempty body,\n     * since they are unsafe and non-idempotent, so each call may mutate\n     * server-side state.\n     *\n     * In the M2 REST API, some POST requests have no body, and those tend\n     * to be idempotent.\n     *\n     * The `multicast` boolean option to the constructor can be used to\n     * override this, either to force `false` or `true`.\n     *\n     * @private\n     */\n    _isMulticastable() {\n        return this.opts.hasOwnProperty('multicast')\n            ? this.opts.multicast\n            : !(this.opts.method === 'POST' && this.opts.body);\n    }\n    /**\n     * Use the Fetch API to place a request to the M2 REST API.\n     * Exposed on prototype for testing only.\n     * @private\n     */\n    /* istanbul ignore next */\n    _transport(...args) {\n        return window.fetch(...args);\n    }\n    /**\n     * Use the AbortController API to make a cancelable fetch request.\n     * Reject on HTTP errors.\n     * @private\n     */\n    _fetch() {\n        return this._transport(this.resourceUrl, this.opts)\n            .then(\n                // When the network operation completes, remove from cache\n                // as a side effect.\n                res => {\n                    MulticastCache.remove(this);\n                    return res;\n                },\n                e => {\n                    MulticastCache.remove(this);\n                    throw e;\n                }\n            )\n            .then(response => {\n                // WHATWG fetch will only reject in the unlikely event\n                // of an error prior to opening the HTTP request.\n                // It pays no attention to HTTP status codes.\n                // But the response object does have an `ok` boolean\n                // corresponding to status codes in the 2xx range.\n                // An M2ApiRequest will reject, passing server errors\n                // to the client, in the event of an HTTP error code.\n                if (!response.ok) {\n                    return (\n                        response\n                            // The response may or may not be JSON.\n                            // Let M2ApiResponseError handle it.\n                            .text()\n                            // Throw a specially formatted error which\n                            // includes the original context of the request,\n                            // and formats the server response.\n                            .then(bodyText => {\n                                throw new M2ApiResponseError({\n                                    method: this.opts.method,\n                                    resourceUrl: this.resourceUrl,\n                                    response,\n                                    bodyText\n                                });\n                            })\n                    );\n                }\n                return response;\n            });\n    }\n    /**\n     * Get a network operation matching this request, either by finding\n     * one in the MulticastCache, or by launching a new one (and caching\n     * it in the MulticastCache).\n     * @private\n     */\n    _fetchMulticast() {\n        // Does an inflight request exist that could be reused here?\n        // That is, does it have the same method, resourceUrl, and body and it\n        // appears idempotent and safe ?\n        const inflightMatch = MulticastCache.match(this);\n\n        // Is this request meant to override an existing inflight request?\n        const rolling = this.isRolling();\n        if (inflightMatch && !rolling) {\n            // Reuse the request!\n            return inflightMatch.getResponse();\n        }\n\n        // Either there is no match, or this is a rolling request\n        // and we must override the match.\n\n        // Cache this request for future use.\n        MulticastCache.store(this);\n\n        const promise = this._fetch().catch(error => {\n            // Rolling requests cause prior matching requests to abort.\n            // Their consumers will get an unexpected error unless we\n            // swallow the AbortError we expect, and replace it with\n            // the promise from our rolling request.\n            if (error.name === 'AbortError') {\n                const replacedInFlightMatch = MulticastCache.match(this);\n                if (replacedInFlightMatch) {\n                    // There is a rolling request in the cache to override!\n                    return replacedInFlightMatch.getResponse();\n                }\n            }\n            throw error;\n        });\n\n        if (rolling && inflightMatch) {\n            inflightMatch.abortRequest();\n        }\n\n        return promise;\n    }\n}\n\nexport default M2ApiRequest;\n\n/**\n * Place a request to the Magento 2 REST API and return a Promise for the\n * response.\n * @param (string) resourceUrl The URL of the resource to request.\n * @param {M2ApiRequestOptions} opts Options to be passed to [fetch](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters), with the addition of the `multicast` option.\n * @returns {Promise} A promise for the parsed REST request.\n */\nexport function request(resourceUrl, opts) {\n    const req = new M2ApiRequest(resourceUrl, opts);\n\n    req.run();\n\n    const promise = req.getResponse();\n\n    if (opts && opts.parseJSON === false) {\n        return promise;\n    }\n    return promise.then(res => res.json());\n}\n"],"file":"M2ApiRequest.js"}