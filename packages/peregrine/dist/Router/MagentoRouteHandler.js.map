{"version":3,"sources":["../../src/Router/MagentoRouteHandler.js"],"names":["React","Component","func","shape","string","resolveUnknownRoute","InternalError","Symbol","NotFound","mountedInstances","WeakSet","MagentoRouteHandler","componentMap","Map","errorState","hasError","internalError","notFound","urls","window","caches","Error","open","location","origin","myCache","addAll","pathname","props","isSearch","add","getRouteComponent","state","isKnown","has","isNotFoundComponent","get","id","shouldReloadRoute","navigator","onLine","delete","apiBase","fetchRoot","fetchRootComponent","default","route","resolvedRoute","type","RootComponent","setRouteComponent","message","symbol","meta","addToCache","catch","e","process","env","NODE_ENV","console","warn","setState","set","loading","children","renderChildren","routeProps","isRequired"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport { func, shape, string } from 'prop-types';\n\n// 2019-01-28 Removed virtual `FETCH_ROOT_COMPONENT` import. It's much cleaner\n// to inject a \"fetchRootComponent\" global at build time, so that's what we\n// changed the MagentoRootComponentsPlugin to do.\nimport resolveUnknownRoute from './resolveUnknownRoute';\n\nconst InternalError = Symbol('InternalError');\nconst NotFound = Symbol('NotFound');\nconst mountedInstances = new WeakSet();\n\nexport default class MagentoRouteHandler extends Component {\n    static propTypes = {\n        apiBase: string.isRequired,\n        children: func,\n        location: shape({\n            pathname: string.isRequired\n        }).isRequired\n    };\n\n    state = {\n        componentMap: new Map(),\n        errorState: {\n            hasError: false,\n            internalError: false,\n            notFound: false\n        }\n    };\n\n    // TODO: Add the ability to customize the cache name\n    async addToCache(urls) {\n        if (!window.caches) {\n            throw new Error(\n                'Current environment does not support CacheStorage at window.caches.'\n            );\n        }\n        const myCache = await window.caches.open(\n            `workbox-runtime-${location.origin}/`\n        );\n        await myCache.addAll(urls);\n    }\n\n    componentDidMount() {\n        const { pathname } = this.props.location;\n        const isSearch = pathname === '/search.html';\n        mountedInstances.add(this);\n        if (!isSearch) {\n            this.getRouteComponent(pathname);\n        }\n    }\n\n    componentDidUpdate() {\n        const { props, state } = this;\n        const { pathname } = props.location;\n        const isKnown = state.componentMap.has(pathname);\n        const isSearch = pathname === '/search.html';\n\n        // `NOTFOUND` component needs a unique id\n        // currently it is set to -1\n        const isNotFoundComponent = isKnown\n            ? state.componentMap.get(pathname).id === -1\n            : false;\n\n        const shouldReloadRoute = isNotFoundComponent && navigator.onLine;\n\n        if ((!isKnown && !isSearch) || shouldReloadRoute) {\n            this.getRouteComponent();\n        }\n    }\n\n    componentWillUnmount() {\n        mountedInstances.delete(this);\n    }\n\n    async getRouteComponent() {\n        const {\n            apiBase,\n            location: { pathname }\n        } = this.props;\n\n        // Depending on the environment, the fetchRootComponent global can be\n        // either an ES module with a `default` property or a plain CJS module.\n        const fetchRoot =\n            'default' in fetchRootComponent\n                ? fetchRootComponent.default\n                : fetchRootComponent;\n\n        try {\n            // try to resolve the route\n            // if this throws, we essentially have a 500 Internal Error\n            const resolvedRoute = await resolveUnknownRoute({\n                apiBase,\n                route: pathname\n            });\n\n            const { type, id } = resolvedRoute;\n\n            // if resolution and destructuring succeed but return no match\n            // then we have a straightforward 404 Not Found\n            if (!type || !id) {\n                throw new Error('404');\n            }\n\n            // at this point we should have a matching RootComponent\n            // if this throws, we essentially have a 500 Internal Error\n            const RootComponent = await fetchRoot(type);\n\n            // associate the matching RootComponent with this location\n            this.setRouteComponent(pathname, RootComponent, { id });\n        } catch ({ message }) {\n            const symbol = message === '404' ? NotFound : InternalError;\n\n            // we don't have a matching RootComponent, but we've checked for one\n            // so associate the appropriate error case with this location\n            this.setRouteComponent(pathname, symbol);\n        }\n    }\n\n    setRouteComponent(pathname, RootComponent, meta) {\n        if (!mountedInstances.has(this)) {\n            // avoid setState if component is not mounted for any reason\n            return;\n        }\n\n        this.addToCache([pathname]).catch(e => {\n            if (process.env.NODE_ENV === 'development') {\n                console.warn(`Could not add ${pathname} to cache:`, e);\n            }\n        });\n\n        this.setState(({ componentMap }) => ({\n            componentMap: new Map(componentMap).set(pathname, {\n                RootComponent,\n                ...meta\n            }),\n            errorState: {\n                hasError: typeof RootComponent === 'symbol',\n                internalError: RootComponent === InternalError,\n                notFound: RootComponent === NotFound\n            }\n        }));\n    }\n\n    renderChildren(loading) {\n        const { props, state } = this;\n        const { children } = props;\n        const { errorState } = state;\n\n        return typeof children === 'function'\n            ? children({ ...errorState, loading })\n            : null;\n    }\n\n    render() {\n        const { props, state } = this;\n        const { pathname } = props.location;\n        const { componentMap, errorState } = state;\n\n        // if we have no record of this pathname, we're still loading\n        // and we have no RootComponent, so render children\n        if (!componentMap.has(pathname)) {\n            return this.renderChildren(true);\n        }\n\n        // if we're in an error state, we're not loading anymore\n        // but we have no RootComponent, so render children\n        if (errorState.hasError) {\n            return this.renderChildren(false);\n        }\n\n        // otherwise we do have a RootComponent, so render it\n        const { RootComponent, ...routeProps } = componentMap.get(pathname);\n\n        return <RootComponent {...routeProps} key={pathname} />;\n    }\n}\n"],"file":"MagentoRouteHandler.js"}