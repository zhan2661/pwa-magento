{"version":3,"sources":["../../../src/util/__tests__/intlPatches.spec.js"],"names":["patches","IntlPolyfill","patchedFormatter","cfg","Proxy","Intl","NumberFormat","undefined","get","target","prop","resolvedOptions","standardFormatter","require","formatToPartsPatch","jest","spyOn","stripWhitespaceFromParts","parts","filter","type","value","test","callToParts","formatter","config","num","toParts","call","compareOutputs","expect","toEqual","style","currency","not","toHaveBeenCalled","useGrouping"],"mappings":"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","sourcesContent":["import patches from '../intlPatches';\nimport IntlPolyfill from 'intl';\n\nconst patchedFormatter = cfg =>\n    new Proxy(Intl.NumberFormat(undefined, cfg), {\n        get(target, prop) {\n            if (prop === 'formatToParts') {\n                return false;\n            }\n            if (prop === 'resolvedOptions') {\n                return () => target.resolvedOptions();\n            }\n            return target[prop];\n        }\n    });\nconst standardFormatter = cfg => IntlPolyfill.NumberFormat(undefined, cfg);\nrequire('intl/locale-data/jsonp/en.js');\n\nconst formatToPartsPatch = jest.spyOn(patches, 'formatToPartsPatch');\n\n// IntlPolyfill behaves differently on Node 8 and Node 10, but only in small\n// ways; namely, for an unrecognized currency, Node 10 inserts additional\n// whitespace between the currency code and the first integer.\n// This test shouldn't care about whitespace, so we pass everything through\n// a filter function that strips those literals with whitespace.\nconst stripWhitespaceFromParts = parts =>\n    parts.filter(\n        ({ type, value }) => !(type === 'literal' && /^\\s*$/.test(value))\n    );\n\nconst callToParts = (formatter, config, num) =>\n    stripWhitespaceFromParts(patches.toParts.call(formatter(config), num));\n\nconst compareOutputs = (config, num) =>\n    expect(callToParts(patchedFormatter, config, num)).toEqual(\n        callToParts(standardFormatter, config, num)\n    );\n\ntest('does not use patch if native method exists', () => {\n    callToParts(\n        standardFormatter,\n        { style: 'currency', currency: 'usd' },\n        12000\n    );\n    expect(formatToPartsPatch).not.toHaveBeenCalled();\n});\n\ntest('matches grouped USD format if currency unrecognized', () =>\n    compareOutputs(\n        {\n            style: 'currency',\n            currency: 'YTT'\n        },\n        12000\n    ));\n\ntest('matches USD format with no grouping', () =>\n    compareOutputs(\n        {\n            style: 'currency',\n            currency: 'USD',\n            useGrouping: false\n        },\n        12000\n    ));\n\ntest('handles zero input', () =>\n    compareOutputs({ style: 'currency', currency: 'USD' }, 0));\n\ntest('fixes and rounds decimals', () =>\n    compareOutputs({ style: 'currency', currency: 'USD' }, 100.1285));\n\ntest('matches EUR format', () =>\n    compareOutputs(\n        {\n            style: 'currency',\n            currency: 'EUR',\n            useGrouping: false\n        },\n        100000.99\n    ));\n"],"file":"intlPatches.spec.js"}