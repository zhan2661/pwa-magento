{"version":3,"sources":["../../src/Router/MagentoRouteHandler.js"],"names":["React","Component","func","shape","string","resolveUnknownRoute","InternalError","Symbol","NotFound","mountedInstances","WeakSet","MagentoRouteHandler","componentMap","Map","errorState","hasError","internalError","notFound","addToCache","urls","window","caches","Error","myCache","open","location","origin","addAll","componentDidMount","pathname","props","isSearch","add","getRouteComponent","componentDidUpdate","state","isKnown","has","isNotFoundComponent","get","id","shouldReloadRoute","navigator","onLine","componentWillUnmount","delete","apiBase","fetchRoot","fetchRootComponent","default","resolvedRoute","route","type","RootComponent","setRouteComponent","message","symbol","meta","catch","e","process","env","NODE_ENV","console","warn","setState","set","renderChildren","loading","children","render","routeProps","isRequired"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport { func, shape, string } from 'prop-types';\n\n// 2019-01-28 Removed virtual `FETCH_ROOT_COMPONENT` import. It's much cleaner\n// to inject a \"fetchRootComponent\" global at build time, so that's what we\n// changed the MagentoRootComponentsPlugin to do.\nimport resolveUnknownRoute from './resolveUnknownRoute';\n\nconst InternalError = Symbol('InternalError');\nconst NotFound = Symbol('NotFound');\nconst mountedInstances = new WeakSet();\n\nexport default class MagentoRouteHandler extends Component {\n    static propTypes = {\n        apiBase: string.isRequired,\n        children: func,\n        location: shape({\n            pathname: string.isRequired\n        }).isRequired\n    };\n\n    state = {\n        componentMap: new Map(),\n        errorState: {\n            hasError: false,\n            internalError: false,\n            notFound: false\n        }\n    };\n\n    // TODO: Add the ability to customize the cache name\n    async addToCache(urls) {\n        if (!window.caches) {\n            throw new Error(\n                'Current environment does not support CacheStorage at window.caches.'\n            );\n        }\n        const myCache = await window.caches.open(\n            `workbox-runtime-${location.origin}/`\n        );\n        await myCache.addAll(urls);\n    }\n\n    componentDidMount() {\n        const { pathname } = this.props.location;\n        const isSearch = pathname === '/search.html';\n        mountedInstances.add(this);\n        if (!isSearch) {\n            this.getRouteComponent(pathname);\n        }\n    }\n\n    componentDidUpdate() {\n        const { props, state } = this;\n        const { pathname } = props.location;\n        const isKnown = state.componentMap.has(pathname);\n        const isSearch = pathname === '/search.html';\n\n        // `NOTFOUND` component needs a unique id\n        // currently it is set to -1\n        const isNotFoundComponent = isKnown\n            ? state.componentMap.get(pathname).id === -1\n            : false;\n\n        const shouldReloadRoute = isNotFoundComponent && navigator.onLine;\n\n        if ((!isKnown && !isSearch) || shouldReloadRoute) {\n            this.getRouteComponent();\n        }\n    }\n\n    componentWillUnmount() {\n        mountedInstances.delete(this);\n    }\n\n    async getRouteComponent() {\n        const {\n            apiBase,\n            location: { pathname }\n        } = this.props;\n\n        // Depending on the environment, the fetchRootComponent global can be\n        // either an ES module with a `default` property or a plain CJS module.\n        const fetchRoot =\n            'default' in fetchRootComponent\n                ? fetchRootComponent.default\n                : fetchRootComponent;\n\n        try {\n            // try to resolve the route\n            // if this throws, we essentially have a 500 Internal Error\n            const resolvedRoute = await resolveUnknownRoute({\n                apiBase,\n                route: pathname\n            });\n\n            const { type, id } = resolvedRoute;\n\n            // if resolution and destructuring succeed but return no match\n            // then we have a straightforward 404 Not Found\n            if (!type || !id) {\n                throw new Error('404');\n            }\n\n            // at this point we should have a matching RootComponent\n            // if this throws, we essentially have a 500 Internal Error\n            const RootComponent = await fetchRoot(type);\n\n            // associate the matching RootComponent with this location\n            this.setRouteComponent(pathname, RootComponent, { id });\n        } catch ({ message }) {\n            const symbol = message === '404' ? NotFound : InternalError;\n\n            // we don't have a matching RootComponent, but we've checked for one\n            // so associate the appropriate error case with this location\n            this.setRouteComponent(pathname, symbol);\n        }\n    }\n\n    setRouteComponent(pathname, RootComponent, meta) {\n        if (!mountedInstances.has(this)) {\n            // avoid setState if component is not mounted for any reason\n            return;\n        }\n\n        this.addToCache([pathname]).catch(e => {\n            if (process.env.NODE_ENV === 'development') {\n                console.warn(`Could not add ${pathname} to cache:`, e);\n            }\n        });\n\n        this.setState(({ componentMap }) => ({\n            componentMap: new Map(componentMap).set(pathname, {\n                RootComponent,\n                ...meta\n            }),\n            errorState: {\n                hasError: typeof RootComponent === 'symbol',\n                internalError: RootComponent === InternalError,\n                notFound: RootComponent === NotFound\n            }\n        }));\n    }\n\n    renderChildren(loading) {\n        const { props, state } = this;\n        const { children } = props;\n        const { errorState } = state;\n\n        return typeof children === 'function'\n            ? children({ ...errorState, loading })\n            : null;\n    }\n\n    render() {\n        const { props, state } = this;\n        const { pathname } = props.location;\n        const { componentMap, errorState } = state;\n\n        // if we have no record of this pathname, we're still loading\n        // and we have no RootComponent, so render children\n        if (!componentMap.has(pathname)) {\n            return this.renderChildren(true);\n        }\n\n        // if we're in an error state, we're not loading anymore\n        // but we have no RootComponent, so render children\n        if (errorState.hasError) {\n            return this.renderChildren(false);\n        }\n\n        // otherwise we do have a RootComponent, so render it\n        const { RootComponent, ...routeProps } = componentMap.get(pathname);\n\n        return <RootComponent {...routeProps} key={pathname} />;\n    }\n}\n"],"file":"MagentoRouteHandler.js"}