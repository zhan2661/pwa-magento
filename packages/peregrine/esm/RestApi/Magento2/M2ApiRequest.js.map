{"version":3,"sources":["../../../src/RestApi/Magento2/M2ApiRequest.js"],"names":["M2ApiResponseError","MulticastCache","BrowserPersistence","withDefaultHeaders","headerAdditions","headers","Headers","Accept","entries","name","value","append","forEach","console","warn","Object","M2ApiRequest","constructor","resourceUrl","opts","storage","signin_token","getItem","controller","AbortController","method","signal","credentials","authorization","run","_isMulticastable","_promise","_fetchMulticast","_fetch","getResponse","Error","then","res","clone","abortRequest","abort","isRolling","cache","hasOwnProperty","multicast","body","_transport","args","window","fetch","remove","e","response","ok","text","bodyText","inflightMatch","match","rolling","store","promise","catch","error","replacedInFlightMatch","request","req","parseJSON","json"],"mappings":";;;;AAAA,OAAOA,kBAAP;AACA,OAAO,KAAKC,cAAZ;AACA,SAASC,kBAAT,sB,CAEA;;AACA,MAAMC,kBAAkB,GAAGC,eAAe,IAAI;AAC1C,QAAMC,OAAO,GAAG,IAAIC,OAAJ,CAAY;AACxB,oBAAgB,kBADQ;AAExBC,IAAAA,MAAM,EAAE;AAFgB,GAAZ,CAAhB;;AAIA,MAAIH,eAAJ,EAAqB;AACjB,QAAIA,eAAe,YAAYE,OAA/B,EAAwC;AACpC;AACA,UAAIF,eAAe,CAACI,OAApB,EAA6B;AACzB,aAAK,MAAM,CAACC,IAAD,EAAOC,KAAP,CAAX,IAA4BN,eAA5B,EAA6C;AACzCC,UAAAA,OAAO,CAACM,MAAR,CAAeF,IAAf,EAAqBC,KAArB;AACH;AACJ,OAJD,MAIO,IAAIN,eAAe,CAACQ,OAApB,EAA6B;AAChC;AACAR,QAAAA,eAAe,CAACQ,OAAhB,CAAwB,CAACH,IAAD,EAAOC,KAAP,KAAiB;AACrCL,UAAAA,OAAO,CAACM,MAAR,CAAeF,IAAf,EAAqBC,KAArB;AACH,SAFD;AAGA;AACH,OANM,MAMA;AACHG,QAAAA,OAAO,CAACC,IAAR,CACI,uDADJ,EAEIV,eAFJ;AAIH;AACJ,KAlBD,MAkBO;AACH,WAAK,MAAM,CAACK,IAAD,EAAOC,KAAP,CAAX,IAA4BK,MAAM,CAACP,OAAP,CAAeJ,eAAf,CAA5B,EAA6D;AACzDC,QAAAA,OAAO,CAACM,MAAR,CAAeF,IAAf,EAAqBC,KAArB;AACH;AACJ;AACJ;;AACD,SAAOL,OAAP;AACH,CA/BD;AAiCA;;;;;;AAMA;;;;;;;;;AAOA,MAAMW,YAAN,CAAmB;AACfC,EAAAA,WAAW,CAACC,WAAD,EAAcC,IAAI,GAAG,EAArB,EAAyB;AAChC,UAAMC,OAAO,GAAG,IAAIlB,kBAAJ,EAAhB;AACA,UAAMmB,YAAY,GAAGD,OAAO,CAACE,OAAR,CAAgB,cAAhB,CAArB;AACA,SAAKC,UAAL,GAAkB,IAAIC,eAAJ,EAAlB;AACA,SAAKN,WAAL,GAAmBA,WAAnB,CAJgC,CAKhC;;AACA,SAAKC,IAAL;AACI;AACAM,MAAAA,MAAM,EAAE,KAFZ;AAGIC,MAAAA,MAAM,EAAE,KAAKH,UAAL,CAAgBG,MAH5B;AAIIC,MAAAA,WAAW,EAAE;AAJjB,OAKOR,IALP;AAMI;AACAd,MAAAA,OAAO,EAAEF,kBAAkB,CACvB,IAAIG,OAAJ,CAAY;AACRsB,QAAAA,aAAa,EAAEP,YAAY,GAAI,UAASA,YAAa,EAA1B,GAA8B;AADjD,OAAZ,CADuB;AAP/B;AAaH;AACD;;;;;;AAIAQ,EAAAA,GAAG,GAAG;AACF,QAAI,KAAKC,gBAAL,EAAJ,EAA6B;AACzB,WAAKC,QAAL,GAAgB,KAAKC,eAAL,EAAhB;AACH,KAFD,MAEO;AACH,WAAKD,QAAL,GAAgB,KAAKE,MAAL,EAAhB;AACH;AACJ;AACD;;;;;;;;;;AAQAC,EAAAA,WAAW,GAAG;AACV,QAAI,CAAC,KAAKH,QAAV,EAAoB;AAChB,YAAM,IAAII,KAAJ,CACF,uFADE,CAAN;AAGH;;AACD,QAAI,KAAKL,gBAAL,EAAJ,EAA6B;AACzB,aAAO,KAAKC,QAAL,CAAcK,IAAd,CAAmBC,GAAG,IAAIA,GAAG,CAACC,KAAJ,EAA1B,CAAP;AACH,KAFD,MAEO;AACH,aAAO,KAAKP,QAAZ;AACH;AACJ;AACD;;;;;;;AAKAQ,EAAAA,YAAY,GAAG;AACX,SAAKhB,UAAL,CAAgBiB,KAAhB;AACH;AACD;;;;;;;;;;;;;;;;;AAeAC,EAAAA,SAAS,GAAG;AACR,WAAO,KAAKtB,IAAL,CAAUuB,KAAV,KAAoB,UAApB,IAAkC,KAAKvB,IAAL,CAAUuB,KAAV,KAAoB,QAA7D;AACH;AACD;;;;;;;;;;;;;;;AAaAZ,EAAAA,gBAAgB,GAAG;AACf,WAAO,KAAKX,IAAL,CAAUwB,cAAV,CAAyB,WAAzB,IACD,KAAKxB,IAAL,CAAUyB,SADT,GAED,EAAE,KAAKzB,IAAL,CAAUM,MAAV,KAAqB,MAArB,IAA+B,KAAKN,IAAL,CAAU0B,IAA3C,CAFN;AAGH;AACD;;;;;;AAKA;;;AACAC,EAAAA,UAAU,CAAC,GAAGC,IAAJ,EAAU;AAChB,WAAOC,MAAM,CAACC,KAAP,CAAa,GAAGF,IAAhB,CAAP;AACH;AACD;;;;;;;AAKAd,EAAAA,MAAM,GAAG;AACL,WAAO,KAAKa,UAAL,CAAgB,KAAK5B,WAArB,EAAkC,KAAKC,IAAvC,EACFiB,IADE,EAEC;AACA;AACAC,IAAAA,GAAG,IAAI;AACHpC,MAAAA,cAAc,CAACiD,MAAf,CAAsB,IAAtB;AACA,aAAOb,GAAP;AACH,KAPF,EAQCc,CAAC,IAAI;AACDlD,MAAAA,cAAc,CAACiD,MAAf,CAAsB,IAAtB;AACA,YAAMC,CAAN;AACH,KAXF,EAaFf,IAbE,CAaGgB,QAAQ,IAAI;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAI,CAACA,QAAQ,CAACC,EAAd,EAAkB;AACd,eACID,QAAQ,CACJ;AACA;AAFI,SAGHE,IAHL,GAII;AACA;AACA;AANJ,SAOKlB,IAPL,CAOUmB,QAAQ,IAAI;AACd,gBAAM,IAAIvD,kBAAJ,CAAuB;AACzByB,YAAAA,MAAM,EAAE,KAAKN,IAAL,CAAUM,MADO;AAEzBP,YAAAA,WAAW,EAAE,KAAKA,WAFO;AAGzBkC,YAAAA,QAHyB;AAIzBG,YAAAA;AAJyB,WAAvB,CAAN;AAMH,SAdL,CADJ;AAiBH;;AACD,aAAOH,QAAP;AACH,KAzCE,CAAP;AA0CH;AACD;;;;;;;;AAMApB,EAAAA,eAAe,GAAG;AACd;AACA;AACA;AACA,UAAMwB,aAAa,GAAGvD,cAAc,CAACwD,KAAf,CAAqB,IAArB,CAAtB,CAJc,CAMd;;AACA,UAAMC,OAAO,GAAG,KAAKjB,SAAL,EAAhB;;AACA,QAAIe,aAAa,IAAI,CAACE,OAAtB,EAA+B;AAC3B;AACA,aAAOF,aAAa,CAACtB,WAAd,EAAP;AACH,KAXa,CAad;AACA;AAEA;;;AACAjC,IAAAA,cAAc,CAAC0D,KAAf,CAAqB,IAArB;;AAEA,UAAMC,OAAO,GAAG,KAAK3B,MAAL,GAAc4B,KAAd,CAAoBC,KAAK,IAAI;AACzC;AACA;AACA;AACA;AACA,UAAIA,KAAK,CAACrD,IAAN,KAAe,YAAnB,EAAiC;AAC7B,cAAMsD,qBAAqB,GAAG9D,cAAc,CAACwD,KAAf,CAAqB,IAArB,CAA9B;;AACA,YAAIM,qBAAJ,EAA2B;AACvB;AACA,iBAAOA,qBAAqB,CAAC7B,WAAtB,EAAP;AACH;AACJ;;AACD,YAAM4B,KAAN;AACH,KAbe,CAAhB;;AAeA,QAAIJ,OAAO,IAAIF,aAAf,EAA8B;AAC1BA,MAAAA,aAAa,CAACjB,YAAd;AACH;;AAED,WAAOqB,OAAP;AACH;;AAvMc;;AA0MnB,eAAe5C,YAAf;AAEA;;;;;;;;AAOA,OAAO,SAASgD,OAAT,CAAiB9C,WAAjB,EAA8BC,IAA9B,EAAoC;AACvC,QAAM8C,GAAG,GAAG,IAAIjD,YAAJ,CAAiBE,WAAjB,EAA8BC,IAA9B,CAAZ;AAEA8C,EAAAA,GAAG,CAACpC,GAAJ;AAEA,QAAM+B,OAAO,GAAGK,GAAG,CAAC/B,WAAJ,EAAhB;;AAEA,MAAIf,IAAI,IAAIA,IAAI,CAAC+C,SAAL,KAAmB,KAA/B,EAAsC;AAClC,WAAON,OAAP;AACH;;AACD,SAAOA,OAAO,CAACxB,IAAR,CAAaC,GAAG,IAAIA,GAAG,CAAC8B,IAAJ,EAApB,CAAP;AACH","sourcesContent":["import M2ApiResponseError from './M2ApiResponseError';\nimport * as MulticastCache from './MulticastCache';\nimport { BrowserPersistence } from '../../util/';\n\n// TODO: headers are locked right now, add configurability\nconst withDefaultHeaders = headerAdditions => {\n    const headers = new Headers({\n        'Content-type': 'application/json',\n        Accept: 'application/json'\n    });\n    if (headerAdditions) {\n        if (headerAdditions instanceof Headers) {\n            /* istanbul ignore next: current phantomJS doesn't support */\n            if (headerAdditions.entries) {\n                for (const [name, value] of headerAdditions) {\n                    headers.append(name, value);\n                }\n            } else if (headerAdditions.forEach) {\n                // cover legacy case for old test environments\n                headerAdditions.forEach((name, value) => {\n                    headers.append(name, value);\n                });\n                /* istanbul ignore next: should never happen, trivial to test*/\n            } else {\n                console.warn(\n                    'Could not use headers object supplied to M2ApiRequest',\n                    headerAdditions\n                );\n            }\n        } else {\n            for (const [name, value] of Object.entries(headerAdditions)) {\n                headers.append(name, value);\n            }\n        }\n    }\n    return headers;\n};\n\n/**\n * All [fetch options](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters) are passed through, with the addition of:\n * @typedef {Object} M2ApiRequestOptions\n * @property {boolean} [multicast] Override default multicast detection\n */\n\n/**\n * A request to the Magento 2 REST API. Returns a Promise created by a network\n * fetch, but can potentially reuse prior requests if they qualify for\n * multicast. Can abort an outstanding fetch request.\n *\n * @param {M2ApiRequestOptions} opts - All other [fetch options](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters) will be passed through to `fetch`.\n */\nclass M2ApiRequest {\n    constructor(resourceUrl, opts = {}) {\n        const storage = new BrowserPersistence();\n        const signin_token = storage.getItem('signin_token');\n        this.controller = new AbortController();\n        this.resourceUrl = resourceUrl;\n        // merge headers specially\n        this.opts = {\n            // can be overridden\n            method: 'GET',\n            signal: this.controller.signal,\n            credentials: 'include',\n            ...opts,\n            // cannot be overridden, only appended to\n            headers: withDefaultHeaders(\n                new Headers({\n                    authorization: signin_token ? `Bearer ${signin_token}` : ''\n                })\n            )\n        };\n    }\n    /**\n     * Execute the request. Must be run before {@link M2ApiRequest#getResponse}\n     * or {@link M2ApiRequest#cancel} can be called.\n     */\n    run() {\n        if (this._isMulticastable()) {\n            this._promise = this._fetchMulticast();\n        } else {\n            this._promise = this._fetch();\n        }\n    }\n    /**\n     * Get the promise for the network operation. Can only be called after\n     * `.run()` is called.\n     * For multicast requests, will return a promise for a new copy of the\n     * response every time it is called, since a Body can only be used once.\n     * Exists so that requests can reuse the promises from other requests.\n     * @returns {Promise} Promise for the result of the request.\n     */\n    getResponse() {\n        if (!this._promise) {\n            throw new Error(\n                'M2ApiRequest#getResponse() called before M2ApiRequest#run(), so no promise exists yet'\n            );\n        }\n        if (this._isMulticastable()) {\n            return this._promise.then(res => res.clone());\n        } else {\n            return this._promise;\n        }\n    }\n    /**\n     * Abort the network operation. Multicasted requests catch the AbortError\n     * and attempt to reuse a more recent matching request from cache. Other\n     * requests will pass the AbortError rejection through to the consumer.\n     */\n    abortRequest() {\n        this.controller.abort();\n    }\n    /**\n     * Check if this request intends to override prior requests to the same\n     * resource. Rolling requests will take the place of prior outstanding\n     * requests, to ensure the freshest resource at the cost of additional\n     * network calls.\n     *\n     * The current logic for rolling requests is determined by the `cache`\n     * option. [Cache modes](https://developer.mozilla.org/en-US/docs/Web/API/Request/cache)\n     * `reload` and `no-store` both indicate complete cache bypass. This\n     * logically implies that the user has just changed server state and wants\n     * to force retrieve an updated resource, so multicasting a prior request\n     * would not be appropriate--the response may not reflect the more recent\n     * change.\n     * @returns {boolean} True if the request is rolling.\n     */\n    isRolling() {\n        return this.opts.cache === 'no-store' || this.opts.cache === 'reload';\n    }\n    /**\n     * Make sure not to multicast POST requests which have a nonempty body,\n     * since they are unsafe and non-idempotent, so each call may mutate\n     * server-side state.\n     *\n     * In the M2 REST API, some POST requests have no body, and those tend\n     * to be idempotent.\n     *\n     * The `multicast` boolean option to the constructor can be used to\n     * override this, either to force `false` or `true`.\n     *\n     * @private\n     */\n    _isMulticastable() {\n        return this.opts.hasOwnProperty('multicast')\n            ? this.opts.multicast\n            : !(this.opts.method === 'POST' && this.opts.body);\n    }\n    /**\n     * Use the Fetch API to place a request to the M2 REST API.\n     * Exposed on prototype for testing only.\n     * @private\n     */\n    /* istanbul ignore next */\n    _transport(...args) {\n        return window.fetch(...args);\n    }\n    /**\n     * Use the AbortController API to make a cancelable fetch request.\n     * Reject on HTTP errors.\n     * @private\n     */\n    _fetch() {\n        return this._transport(this.resourceUrl, this.opts)\n            .then(\n                // When the network operation completes, remove from cache\n                // as a side effect.\n                res => {\n                    MulticastCache.remove(this);\n                    return res;\n                },\n                e => {\n                    MulticastCache.remove(this);\n                    throw e;\n                }\n            )\n            .then(response => {\n                // WHATWG fetch will only reject in the unlikely event\n                // of an error prior to opening the HTTP request.\n                // It pays no attention to HTTP status codes.\n                // But the response object does have an `ok` boolean\n                // corresponding to status codes in the 2xx range.\n                // An M2ApiRequest will reject, passing server errors\n                // to the client, in the event of an HTTP error code.\n                if (!response.ok) {\n                    return (\n                        response\n                            // The response may or may not be JSON.\n                            // Let M2ApiResponseError handle it.\n                            .text()\n                            // Throw a specially formatted error which\n                            // includes the original context of the request,\n                            // and formats the server response.\n                            .then(bodyText => {\n                                throw new M2ApiResponseError({\n                                    method: this.opts.method,\n                                    resourceUrl: this.resourceUrl,\n                                    response,\n                                    bodyText\n                                });\n                            })\n                    );\n                }\n                return response;\n            });\n    }\n    /**\n     * Get a network operation matching this request, either by finding\n     * one in the MulticastCache, or by launching a new one (and caching\n     * it in the MulticastCache).\n     * @private\n     */\n    _fetchMulticast() {\n        // Does an inflight request exist that could be reused here?\n        // That is, does it have the same method, resourceUrl, and body and it\n        // appears idempotent and safe ?\n        const inflightMatch = MulticastCache.match(this);\n\n        // Is this request meant to override an existing inflight request?\n        const rolling = this.isRolling();\n        if (inflightMatch && !rolling) {\n            // Reuse the request!\n            return inflightMatch.getResponse();\n        }\n\n        // Either there is no match, or this is a rolling request\n        // and we must override the match.\n\n        // Cache this request for future use.\n        MulticastCache.store(this);\n\n        const promise = this._fetch().catch(error => {\n            // Rolling requests cause prior matching requests to abort.\n            // Their consumers will get an unexpected error unless we\n            // swallow the AbortError we expect, and replace it with\n            // the promise from our rolling request.\n            if (error.name === 'AbortError') {\n                const replacedInFlightMatch = MulticastCache.match(this);\n                if (replacedInFlightMatch) {\n                    // There is a rolling request in the cache to override!\n                    return replacedInFlightMatch.getResponse();\n                }\n            }\n            throw error;\n        });\n\n        if (rolling && inflightMatch) {\n            inflightMatch.abortRequest();\n        }\n\n        return promise;\n    }\n}\n\nexport default M2ApiRequest;\n\n/**\n * Place a request to the Magento 2 REST API and return a Promise for the\n * response.\n * @param (string) resourceUrl The URL of the resource to request.\n * @param {M2ApiRequestOptions} opts Options to be passed to [fetch](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters), with the addition of the `multicast` option.\n * @returns {Promise} A promise for the parsed REST request.\n */\nexport function request(resourceUrl, opts) {\n    const req = new M2ApiRequest(resourceUrl, opts);\n\n    req.run();\n\n    const promise = req.getResponse();\n\n    if (opts && opts.parseJSON === false) {\n        return promise;\n    }\n    return promise.then(res => res.json());\n}\n"],"file":"M2ApiRequest.js"}