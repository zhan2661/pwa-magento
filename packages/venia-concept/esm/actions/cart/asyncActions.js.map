{"version":3,"sources":["../../../src/actions/cart/asyncActions.js"],"names":["RestApi","Util","closeDrawer","toggleDrawer","checkoutActions","actions","request","Magento2","BrowserPersistence","storage","createGuestCart","thunk","dispatch","getState","cart","guestCartId","reset","retrieveGuestCartId","getGuestCart","receive","id","method","saveGuestCartId","error","addItemToCart","payload","item","options","parentSku","productType","quantity","writingImageToCache","writeImageToCache","addItem","user","isSignedIn","missingGuestCartError","Error","noGuestCartId","itemPayload","qty","sku","name","quote_id","Object","assign","product_type","product_option","extension_attributes","configurable_item_options","cartItem","body","JSON","stringify","getCartDetails","forceRefresh","response","status","clearGuestCartId","arguments","updateItemInCart","targetItemId","updateItem","Promise","all","closeOptionsDrawer","removeItemFromCart","removeItem","cartItemCount","details","items_count","item_id","openOptionsDrawer","getDetails","imageCache","paymentMethods","totals","retrieveImageCache","fetchCartPart","subResource","items","Array","isArray","length","validTotals","forEach","image","matchingItem","find","t","parse","toggleCart","app","drawer","removeGuestCart","args","type","cache","getGuestCartId","getItem","setItem","saveImageCache","media_gallery_entries","media","m","position"],"mappings":"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","sourcesContent":["import { RestApi, Util } from '@magento/peregrine';\n\nimport { closeDrawer, toggleDrawer } from 'src/actions/app';\nimport checkoutActions from 'src/actions/checkout';\nimport actions from './actions';\n\nconst { request } = RestApi.Magento2;\nconst { BrowserPersistence } = Util;\nconst storage = new BrowserPersistence();\n\nexport const createGuestCart = () =>\n    async function thunk(dispatch, getState) {\n        const { cart } = getState();\n\n        // if a guest cart already exists, exit\n        if (cart.guestCartId) {\n            return;\n        }\n\n        // reset the checkout workflow\n        // in case the user has already completed an order this session\n        dispatch(checkoutActions.reset());\n\n        const guestCartId = await retrieveGuestCartId();\n\n        // if a guest cart exists in storage, act like we just received it\n        if (guestCartId) {\n            dispatch(actions.getGuestCart.receive(guestCartId));\n            return;\n        }\n\n        // otherwise, request a new guest cart\n        dispatch(actions.getGuestCart.request());\n\n        try {\n            const id = await request('/rest/V1/guest-carts', {\n                method: 'POST'\n            });\n\n            // write to storage in the background\n            saveGuestCartId(id);\n            dispatch(actions.getGuestCart.receive(id));\n        } catch (error) {\n            dispatch(actions.getGuestCart.receive(error));\n        }\n    };\n\nexport const addItemToCart = (payload = {}) => {\n    const { item, options, parentSku, productType, quantity } = payload;\n    const writingImageToCache = writeImageToCache(item);\n\n    return async function thunk(dispatch, getState) {\n        await writingImageToCache;\n        dispatch(actions.addItem.request(payload));\n\n        const { user } = getState();\n        if (user.isSignedIn) {\n            // TODO: handle authed carts\n            // if a user creates an account,\n            // then the guest cart will be transferred to their account\n            // causing `/guest-carts` to 400\n            return;\n        }\n\n        try {\n            const { cart } = getState();\n            const { guestCartId } = cart;\n\n            if (!guestCartId) {\n                const missingGuestCartError = new Error(\n                    'Missing required information: guestCartId'\n                );\n                missingGuestCartError.noGuestCartId = true;\n                throw missingGuestCartError;\n            }\n\n            // TODO: change to GraphQL mutation\n            // for now, manually transform the payload for REST\n            const itemPayload = {\n                qty: quantity,\n                sku: item.sku,\n                name: item.name,\n                quote_id: guestCartId\n            };\n\n            if (productType === 'ConfigurableProduct') {\n                Object.assign(itemPayload, {\n                    sku: parentSku,\n                    product_type: 'configurable',\n                    product_option: {\n                        extension_attributes: {\n                            configurable_item_options: options\n                        }\n                    }\n                });\n            }\n\n            const cartItem = await request(\n                `/rest/V1/guest-carts/${guestCartId}/items`,\n                {\n                    method: 'POST',\n                    body: JSON.stringify({\n                        cartItem: itemPayload\n                    })\n                }\n            );\n\n            // 2019-02-07  Moved these dispatches to the success clause of\n            // addItemToCart. The cart should only open on success.\n            // In the catch clause, this action creator calls its own thunk,\n            // so a successful retry will wind up here anyway.\n            await dispatch(getCartDetails({ forceRefresh: true }));\n            await dispatch(toggleDrawer('cart'));\n            dispatch(actions.addItem.receive({ cartItem, item, quantity }));\n        } catch (error) {\n            const { response, noGuestCartId } = error;\n\n            dispatch(actions.addItem.receive(error));\n\n            // check if the guest cart has expired\n            if (noGuestCartId || (response && response.status === 404)) {\n                // if so, then delete the cached ID...\n                // in contrast to the save, make sure storage deletion is\n                // complete before dispatching the error--you don't want an\n                // upstream action to try and reuse the known-bad ID.\n                await clearGuestCartId();\n                // then create a new one\n                await dispatch(createGuestCart());\n                // then retry this operation\n                return thunk(...arguments);\n            }\n        }\n    };\n};\n\nexport const updateItemInCart = (payload = {}, targetItemId) => {\n    const { item, options, parentSku, productType, quantity } = payload;\n    const writingImageToCache = writeImageToCache(item);\n\n    return async function thunk(dispatch, getState) {\n        await writingImageToCache;\n        dispatch(actions.updateItem.request(payload));\n\n        const { user } = getState();\n        if (user.isSignedIn) {\n            // TODO: handle authed carts\n            // if a user creates an account,\n            // then the guest cart will be transferred to their account\n            // causing `/guest-carts` to 400\n            return;\n        }\n\n        try {\n            const { cart } = getState();\n            const { guestCartId } = cart;\n\n            if (!guestCartId) {\n                const missingGuestCartError = new Error(\n                    'Missing required information: guestCartId'\n                );\n                missingGuestCartError.noGuestCartId = true;\n                throw missingGuestCartError;\n            }\n\n            // TODO: change to GraphQL mutation\n            // for now, manually transform the payload for REST\n            const itemPayload = {\n                qty: quantity,\n                sku: item.sku,\n                name: item.name,\n                quote_id: guestCartId\n            };\n\n            if (productType === 'ConfigurableProduct') {\n                Object.assign(itemPayload, {\n                    sku: parentSku,\n                    product_type: 'configurable',\n                    product_option: {\n                        extension_attributes: {\n                            configurable_item_options: options\n                        }\n                    }\n                });\n            }\n\n            const cartItem = await request(\n                `/rest/V1/guest-carts/${guestCartId}/items/${targetItemId}`,\n                {\n                    method: 'PUT',\n                    body: JSON.stringify({\n                        cartItem: itemPayload\n                    })\n                }\n            );\n\n            dispatch(actions.updateItem.receive({ cartItem, item, quantity }));\n        } catch (error) {\n            const { response, noGuestCartId } = error;\n\n            dispatch(actions.updateItem.receive(error));\n\n            // check if the guest cart has expired\n            if (noGuestCartId || (response && response.status === 404)) {\n                // if so, then delete the cached ID...\n                // in contrast to the save, make sure storage deletion is\n                // complete before dispatching the error--you don't want an\n                // upstream action to try and reuse the known-bad ID.\n                await clearGuestCartId();\n                // then create a new one\n                await dispatch(createGuestCart());\n                // then retry this operation\n                return thunk(...arguments);\n            }\n        }\n\n        await Promise.all([\n            dispatch(toggleDrawer('cart')),\n            dispatch(getCartDetails({ forceRefresh: true }))\n        ]);\n        // This is done here as a dispatch instead of as part of\n        // updateItem.receive() so that the cart will close the options\n        // drawer only after it's finished updating\n        dispatch(closeOptionsDrawer());\n    };\n};\n\nexport const removeItemFromCart = payload => {\n    const { item } = payload;\n\n    return async function thunk(dispatch, getState) {\n        dispatch(actions.removeItem.request(payload));\n\n        try {\n            const { cart } = getState();\n            const { guestCartId } = cart;\n            const cartItemCount = cart.details ? cart.details.items_count : 0;\n\n            if (!guestCartId) {\n                const missingGuestCartError = new Error(\n                    'Missing required information: guestCartId'\n                );\n                missingGuestCartError.noGuestCartId = true;\n                throw missingGuestCartError;\n            }\n\n            const cartItem = await request(\n                `/rest/V1/guest-carts/${guestCartId}/items/${item.item_id}`,\n                {\n                    method: 'DELETE'\n                }\n            );\n            // When removing the last item in the cart, perform a reset\n            // to prevent a bug where the next item added to the cart has\n            // a price of 0\n            if (cartItemCount == 1) {\n                await clearGuestCartId();\n            }\n\n            dispatch(\n                actions.removeItem.receive({ cartItem, item, cartItemCount })\n            );\n        } catch (error) {\n            const { response, noGuestCartId } = error;\n\n            dispatch(actions.removeItem.receive(error));\n\n            // check if the guest cart has expired\n            if (noGuestCartId || (response && response.status === 404)) {\n                // if so, then delete the cached ID...\n                // in contrast to the save, make sure storage deletion is\n                // complete before dispatching the error--you don't want an\n                // upstream action to try and reuse the known-bad ID.\n                await clearGuestCartId();\n                // then create a new one\n                await dispatch(createGuestCart());\n                // then retry this operation\n                return thunk(...arguments);\n            }\n        }\n\n        await dispatch(\n            getCartDetails({\n                forceRefresh: true\n            })\n        );\n    };\n};\n\nexport const openOptionsDrawer = () => async dispatch =>\n    dispatch(actions.openOptionsDrawer());\n\nexport const closeOptionsDrawer = () => async dispatch =>\n    dispatch(actions.closeOptionsDrawer());\n\nexport const getCartDetails = (payload = {}) => {\n    const { forceRefresh } = payload;\n\n    return async function thunk(dispatch, getState) {\n        const { cart, user } = getState();\n        const { guestCartId } = cart;\n\n        if (user.isSignedIn) {\n            // TODO: handle authed carts\n            // if a user creates an account,\n            // then the guest cart will be transferred to their account\n            // causing `/guest-carts` to 400\n            return;\n        }\n\n        // if there isn't a guest cart, create one\n        // then retry this operation\n        if (!guestCartId) {\n            await dispatch(createGuestCart());\n            return thunk(...arguments);\n        }\n\n        // Once we have the cart id indicate that we are starting to make\n        // async requests for the details.\n        dispatch(actions.getDetails.request(guestCartId));\n\n        try {\n            const [\n                imageCache,\n                details,\n                paymentMethods,\n                totals\n            ] = await Promise.all([\n                retrieveImageCache(),\n                fetchCartPart({\n                    guestCartId,\n                    forceRefresh\n                }),\n                fetchCartPart({\n                    guestCartId,\n                    forceRefresh,\n                    subResource: 'payment-methods'\n                }),\n                fetchCartPart({\n                    guestCartId,\n                    forceRefresh,\n                    subResource: 'totals'\n                })\n            ]);\n\n            const { items } = details;\n\n            // for each item in the cart, look up its image in the cache\n            // and merge it into the item object\n            // then assign its options from the totals subResource\n            if (imageCache && Array.isArray(items) && items.length) {\n                const validTotals = totals && totals.items;\n                items.forEach(item => {\n                    item.image = item.image || imageCache[item.sku] || {};\n\n                    let options = [];\n                    if (validTotals) {\n                        const matchingItem = totals.items.find(\n                            t => t.item_id === item.item_id\n                        );\n                        if (matchingItem && matchingItem.options) {\n                            options = JSON.parse(matchingItem.options);\n                        }\n                    }\n                    item.options = options;\n                });\n            }\n\n            dispatch(\n                actions.getDetails.receive({ details, paymentMethods, totals })\n            );\n        } catch (error) {\n            const { response } = error;\n\n            dispatch(actions.getDetails.receive(error));\n\n            // check if the guest cart has expired\n            if (response && response.status === 404) {\n                // if so, then delete the cached ID...\n                // in contrast to the save, make sure storage deletion is\n                // complete before dispatching the error--you don't want an\n                // upstream action to try and reuse the known-bad ID.\n                await clearGuestCartId();\n                // then create a new one\n                await dispatch(createGuestCart());\n                // then retry this operation\n                return thunk(...arguments);\n            }\n        }\n    };\n};\n\nexport const toggleCart = () =>\n    async function thunk(dispatch, getState) {\n        const { app, cart } = getState();\n\n        // ensure state slices are present\n        if (!app || !cart) {\n            return;\n        }\n\n        // if the cart drawer is open, close it\n        if (app.drawer === 'cart') {\n            return dispatch(closeDrawer());\n        }\n\n        // otherwise open the cart and load its contents\n        await Promise.all([\n            dispatch(toggleDrawer('cart')),\n            dispatch(getCartDetails())\n        ]);\n    };\n\nexport const removeGuestCart = () =>\n    async function thunk(...args) {\n        const [dispatch, getState] = args;\n        const { cart } = getState();\n        // ensure state slices are present\n        if (!cart) {\n            return;\n        }\n        if (cart['guestCartId']) {\n            dispatch({\n                type: 'REMOVE_GUEST_CART'\n            });\n        }\n    };\n\n/* helpers */\n\nasync function fetchCartPart({ guestCartId, forceRefresh, subResource = '' }) {\n    return request(`/rest/V1/guest-carts/${guestCartId}/${subResource}`, {\n        cache: forceRefresh ? 'reload' : 'default'\n    });\n}\n\nexport async function getGuestCartId(dispatch, getState) {\n    const { cart } = getState();\n    // reducers may be added asynchronously\n    if (!cart) {\n        return null;\n    }\n    // create a guest cart if one hasn't been created yet\n    if (!cart.guestCartId) {\n        await dispatch(createGuestCart());\n    }\n    // retrieve app state again\n    return getState().cart.guestCartId;\n}\n\nexport async function retrieveGuestCartId() {\n    return storage.getItem('guestCartId');\n}\n\nexport async function saveGuestCartId(id) {\n    return storage.setItem('guestCartId', id);\n}\n\nexport async function clearGuestCartId() {\n    return storage.removeItem('guestCartId');\n}\n\nasync function retrieveImageCache() {\n    return storage.getItem('imagesBySku') || {};\n}\n\nasync function saveImageCache(cache) {\n    return storage.setItem('imagesBySku', cache);\n}\n\nasync function writeImageToCache(item = {}) {\n    const { media_gallery_entries: media, sku } = item;\n\n    if (sku) {\n        const image = media && (media.find(m => m.position === 1) || media[0]);\n\n        if (image) {\n            const imageCache = await retrieveImageCache();\n\n            // if there is an image and it differs from cache\n            // write to cache and save in the background\n            if (imageCache[sku] !== image) {\n                imageCache[sku] = image;\n                saveImageCache(imageCache);\n\n                return image;\n            }\n        }\n    }\n}\n"],"file":"asyncActions.js"}