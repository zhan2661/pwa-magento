{"version":3,"sources":["../../src/middleware/errorHandler.js"],"names":["app","errorRecord","APP_DISMISS_ERROR","markErrorHandled","toString","sliceHandledError","state","error","foundEntry","Object","entries","find","slice","values","includes","errorReducer","action","unhandledErrors","type","payload","Error","errorsMinusDismissed","filter","record","process","env","NODE_ENV","length","console","sliceHandled","allErrors","Set","add","window","wrapReducerWithErrorHandling","rootReducer","errorHandlingRootReducer","restOfState","nextState","call","createErrorHandlingStore","createStore","reducer","args"],"mappings":"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","sourcesContent":["/**\n * Handle unhandled errors by setting a global error state.\n *\n * \"store slice\" reducers may want to handle errors in a custom way, in order\n * to display more specific error states (such as form field validation).\n *\n * These reducers can indicate that an error is handled and needs no more UI\n * response, by assigning the error object to the `error` property on their\n * store slice.\n *\n * This reducer activates when the action has an `error` property. It then\n * checks each store slice for an `error` property which equals the error in\n * the action, indicating that the error has already been handled. If it\n * detects that the error is not present in any store slice, it assumes the\n * error is unhandled and pushes it into an `errors` array property on the root\n * store.\n *\n * This `errors` collection represents unhandled errors to be displayed in the\n * next render. To dismiss an error, dispatch the ERROR_DISMISS action with the\n * error as payload, and this reducer will remove it from the array.\n *\n */\nimport app from 'src/actions/app';\nimport errorRecord from 'src/util/createErrorRecord';\nconst APP_DISMISS_ERROR = app.markErrorHandled.toString();\n\n/**\n * This function returns the name of the slice for logging purposes, and\n * undefined if no slice handling this error is found. It uses\n * Object.entries() to create a [name, sliceObject] pair for each slice;\n * the iteratee only tests the value, but we destructure the name into the\n * final return value. For instance, the cart slice is represented as an\n * entry [\"cart\", cartState]. If cartState has any property whose value is\n * the provided error, then this function will return the string \"cart\".\n *\n * @param {object} fullStoreState\n * @param {Error} error\n *\n */\nfunction sliceHandledError(state, error) {\n    const foundEntry = Object.entries(state).find(\n        ([, slice]) =>\n            typeof slice === 'object' &&\n            // A slice is considered to have \"handled\" the error if it\n            // includes a root property (of any name) with the error as a\n            // value. This is the pattern with existing reducers.\n            Object.values(slice).includes(error)\n    );\n    if (foundEntry) {\n        // Return the name of the slice.\n        return foundEntry[0];\n    }\n}\n\n/**\n * This reducer handles the full store state (all slices) and adds any\n * unhandled errors (as defined by the selector function\n * sliceHandledError() defined above) to a root `unhandledErrors`\n * collection. It also handles the app-level action `APP_DISMISS_ERROR` by\n * removing the passed error from that collection. Any global error UI can\n * use this action (as a click handler, for instance) to dismiss the error.\n *\n * @param {object} fullStoreState\n * @param {object} action\n */\nfunction errorReducer(state, action) {\n    const { unhandledErrors } = state;\n    const { type, payload } = action;\n\n    // The `error` property should be boolean and the payload is the error\n    // itself, but just in case someone got that wrong...\n    let error;\n    if (action.error instanceof Error) {\n        error = action.error;\n    } else if (payload instanceof Error) {\n        error = payload;\n    } else {\n        // No error, so nothing this reducer can do.\n        return state;\n    }\n    if (type === APP_DISMISS_ERROR) {\n        const errorsMinusDismissed = unhandledErrors.filter(\n            record => record.error !== error\n        );\n        // If the array is the same size, then the error wasn't here\n        // but it should have been!\n        if (\n            process.env.NODE_ENV === 'development' &&\n            errorsMinusDismissed.length == unhandledErrors.length\n        ) {\n            console.error(\n                'Received ${APP_DISMISS_ERROR} action, but provided error \"${error}\" was not present in the state.unhandledErrors collection. The error object in the action payload must be strictly equal to the error to be dismissed.',\n                error\n            );\n        }\n        return {\n            ...state,\n            unhandledErrors: errorsMinusDismissed\n        };\n    }\n\n    // Handle any other action that may have produced an error.\n    const sliceHandled = sliceHandledError(state, error);\n    if (!sliceHandled) {\n        // No one took this one. Add it to the unhandled list.\n        const allErrors = [\n            // Dedupe errors in case this one is dispatched repeatedly\n            ...new Set(unhandledErrors).add(\n                errorRecord(\n                    error,\n                    // `errorRecord()` requires the window argument for\n                    // testability, through injection of the\n                    // non-idempotent Date and Math methods for IDs.\n                    window,\n                    // Also call `errorRecord()` with the current\n                    // context, which is the root reducer; that enables\n                    // it to trim useful stack traces by omitting\n                    // useless lines.\n                    this\n                )\n            )\n        ];\n        return {\n            ...state,\n            unhandledErrors: allErrors\n        };\n    }\n    // If we get here, a slice DID handle it and indicated that by\n    // setting it as a root property of the slice.\n    return state;\n}\n\n/**\n * Wrapper function for a Redux reducer which adds an error reducer and a root\n * `unhandledErrors` collection to state. Since many reducers validate their\n * state objects, they will error if they see the \"unrecognized\"\n * `unhandledErrors` property. This function hides that property by extracting\n * it from state, then running the passed root reducer on the clean state, then\n * recombining the state and transforming it with the error reducer.\n *\n * @param {Function} rootReducer Original root reducer.\n */\nfunction wrapReducerWithErrorHandling(rootReducer) {\n    return function errorHandlingRootReducer(state = {}, action) {\n        const { unhandledErrors = [], ...restOfState } = state;\n        const nextState = rootReducer(restOfState, action);\n        nextState.unhandledErrors = unhandledErrors;\n        // Apply errorReducer in the context of this root reducer,\n        // so it can trim stack traces using `this`.\n        return errorReducer.call(errorHandlingRootReducer, nextState, action);\n    };\n}\n\n/**\n * Store enhancer which returns a StoreCreator, which accepts a\n * root reducer and an initial state and returns a new store.\n * It is in this function that we can intercept the root reducer\n * and wrap it with error handling.\n */\nexport default function createErrorHandlingStore(createStore) {\n    return (reducer, ...args) =>\n        createStore(wrapReducerWithErrorHandling(reducer), ...args);\n}\n"],"file":"errorHandler.js"}